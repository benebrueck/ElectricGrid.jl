        - # ?
        0 function custom_lsim(sys::AbstractStateSpace, u::AbstractVecOrMat, t::AbstractVector;
        -     x0::AbstractVecOrMat=zeros(Bool, nstates(sys)), method::Symbol=:zoh)
        0     ny, nu = size(sys)
        0     nx = sys.nx
        - 
        0     if length(x0) != nx
        0         error("size(x0) must match the number of states of sys")
        -     end
        0     if size(u) != (nu, length(t))
        0         error("u must be of size (nu, length(t))")
        -     end
        - 
        0     dt = Float64(t[2] - t[1])
        0     if !all(x -> x â‰ˆ dt, diff(t))
        0         error("time vector t must be uniformly spaced")
        -     end
        - 
        -     if iscontinuous(sys)
        -         if method === :zoh
        -             dsys = c2d(sys, dt, :zoh)
        -         elseif method === :foh
        -             dsys, x0map = c2d_x0map(sys, dt, :foh)
        -             x0 = x0map * [x0; u[:, 1]]
        -         else
        -             error("Unsupported discretization method: $method")
        -         end
        -     else
        0         if !(isapprox(sys.Ts, dt))
        0             error("Time vector must match sample time of discrete-time system")
        -         end
        -         dsys = sys
        -     end
        - 
        0     x = custom_ltitr(dsys.A, dsys.B, u, x0)
        -     #y = sys.C * x + sys.D * u
        -     #return SimResult(y, t, x, u, dsys) # saves the system that actually produced the simulation
        0     return x
        - end
        - 
        - @views function custom_ltitr(A::AbstractMatrix, B::AbstractMatrix, u::AbstractVecOrMat,
        -     x0::AbstractVecOrMat=zeros(eltype(A), size(A, 1)))
        - 
        -     T = promote_type(LinearAlgebra.promote_op(LinearAlgebra.matprod, eltype(A), eltype(x0)),
        -         LinearAlgebra.promote_op(LinearAlgebra.matprod, eltype(B), eltype(u)))
        - 
        0     n = size(u, 2)
        - 
        -     # Using similar instead of Matrix{T} to allow for CuArrays to be used.
        -     # This approach is problematic if x0 is sparse for example, but was considered
        -     # to be good enough for now
  9216000     x = similar(x0, T, (length(x0), n))
        - 
        0     x[:, 1] .= x0
        - 
        -     pythoncompare = false
        - 
        -     if pythoncompare
        -         print("u")
        -     else
        0         mul!(x[:, 2:end], B, u[:, 1:end-1]) # Do all multiplications B*u[:,k] to save view allocations
        -     end
        - 
        0     for k = 1:n-1
        -         if pythoncompare
        -             mul!(x[:, k+1], B, u[:, k])
        -             mul!(x[:, k+1], A, x[:, k], true, true)
        -         else
        0             mul!(x[:, k+1], A, x[:, k], true, true)
        -         end
        0     end
        0     return x
        - end
