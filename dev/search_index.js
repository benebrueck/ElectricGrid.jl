var documenterSearchIndex = {"docs":
[{"location":"references/","page":"References","title":"References","text":"Modules = [JEG]\nOrder   = [:function, :type]","category":"page"},{"location":"references/#JEG.AckermannGainMatrix-Tuple{Any, Any, Any}","page":"References","title":"JEG.AckermannGainMatrix","text":"K = AckermannGainMatrix(λ)\n\nDescription\n\nFinds the Ackermann Gain Matrix given the chosen eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.ButterworthLPF-NTuple{4, Any}","page":"References","title":"JEG.ButterworthLPF","text":"ButterworthLPF(fc, x, y, μ) - Low Pass Filter\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.CableLengthSetup-Tuple{Any}","page":"References","title":"JEG.CableLengthSetup","text":"CableLengthSetup(num_cables; random=0, length_bounds=[0.5; 1.5])\n\nunder development\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.CharpolyCoef-Tuple{Any}","page":"References","title":"JEG.CharpolyCoef","text":"α = CharpolyCoef(λ)\n\nDescription\n\ngiven the roots, this function finds the coefficients\n\nReturn Values\n\nα: vector of length(λ)\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.CheckParameters-NTuple{7, Any}","page":"References","title":"JEG.CheckParameters","text":"CheckParameters(parameters, num_sources, num_loads, num_connections, CM, ts, verbosity)\n\nChecks the parameter dict for completeness.\n\nGets parameters and controls the entries based on the given inputs num_sources, num_loads, num_connections, CM and ts. Messages can be suppressed by verbosity.\n\nArguments\n\nparameters::Dict: dict containing all parameters of the node\nnum_sources::Int: number of sources\nnum_loads::Int: number of loads\nnum_connections::Int: number of connections\nCM::Matrix: connectivity matrix describing the connections in the grid\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.CheckPowerBalance-NTuple{4, Any}","page":"References","title":"JEG.CheckPowerBalance","text":"p_load_total, q_load_total, s_load_total, s_source_total = CheckPowerBalance(parameters)\n\nDescription\n\nDetermines based on the parameters of the grid the total power (active and reactive) drawn from all load and the total power provided by the sources. Thereby, steady state is assumed.\n\nArguments\n\nparameters::Dict: Completly filled parameter dict which defines the electrical power grid used in the env/node_constructor.\nnum_source::Int: number of sources in the grid (todo: calulate based on parameter dict?)\nnum_load::Int: number of num_load in the grid (todo: calulate based on parameter dict?)\nCM::Matrix: connectivity matrix describing the connections in the grid\n\nReturn Values\n\np_load_total::float: total active power drawn by all loads (passive components as well as controlled with negative reference value)\nq_load_total::float: total reactive power drawn by all loads\nsloadtotal::float`: total apparent power drawn by all loads\ns_source_total::float: total apparent power provided by all sources in steady state\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.ClarkeMag-Tuple{Any}","page":"References","title":"JEG.ClarkeMag","text":"Description\n\nScaled L2 norm in αβγ coordinates - intantaneous approximation of rms for 3 phase systems\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.ClassicalControl-Tuple{ClassicalPolicy, ElectricGridEnv}","page":"References","title":"JEG.ClassicalControl","text":"ClassicalControl(ClassicalPolicy, ElectricGridEnv)\n\nDescription\n\nLoops through all of the sources, obtaining measurments from the environment and  calculating the actions.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.CountFilters-Tuple{Any}","page":"References","title":"JEG.CountFilters","text":"CountFilters(source_list)\n\nCounts the number of filter types, if parameters is passed.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.CountLoads-Tuple{Any}","page":"References","title":"JEG.CountLoads","text":"CountLoads(load_list)\n\nCounts the number of load types, if parameters is passed.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.CurrentController-Tuple{ClassicalControls, Any, Any, Any}","page":"References","title":"JEG.CurrentController","text":"CurrentController(Source::ClassicalControls, num_source, θ, ω; Kb = 1)\n\nDescription\n\nInner current control with anti-windup.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.CurrentPILoopShaping-Tuple{ClassicalControls, Any}","page":"References","title":"JEG.CurrentPILoopShaping","text":"CurrentPILoopShaping(Source::ClassicalControls, num_source)\n\nDescription\n\nTuning of proportional and integral gain for inner current controller.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.CustomRun","page":"References","title":"JEG.CustomRun","text":"Wrapps the Run function form https://juliareinforcementlearning.org/ to enable turning off the action noise.\n\n\n\n\n\n","category":"function"},{"location":"references/#JEG.DefaultDataHook-Tuple{Any, Any}","page":"References","title":"JEG.DefaultDataHook","text":"which signals are the default ones if the user does not define a data hook for plotting\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.DividedDiff-Tuple{Any, Any}","page":"References","title":"JEG.DividedDiff","text":"DividedDiff(x, y)\n\nDescription\n\nCalculates the coefficients required for Newton interpolation using a divided differences algorithm.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.DrawGraph-Tuple{NodeConstructor}","page":"References","title":"JEG.DrawGraph","text":"DrawGraph(self::NodeConstructor)\n\nPlotting a graphical representation of the grid.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.DroopControlMode-Tuple{ClassicalControls, Any}","page":"References","title":"JEG.DroopControlMode","text":"DroopControlMode(Source::ClassicalControls, num_source; t_end = 0.04)\n\nDescription\n\nWrapper for simple grid forming control.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.EnvInterface-Tuple{ClassicalControls}","page":"References","title":"JEG.EnvInterface","text":"EnvInterface(ClassicalControls)\n\nDescription\n\nPasses the actions back to the environment.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.FaultLevel-Tuple{Any, Any, Any}","page":"References","title":"JEG.FaultLevel","text":"R, L = FaultLevel(S, X_R, Vrms; fsys = 50, phase = 3)\n\nArguments\n\nS::Float: 3 phase Fault Level [VA]\nX/R::Float: the (Short Circuit) ratio of reactance to resistance\nVrms::Float: Line to Neutral rms voltage of external network [V]\n\nKeyword Arguments\n\nfsys::Float: system frequency [Hz]\nphase::Int: single or 3 phase system, i.e. phase = 1, or phase = 3\n\nReturn Values\n\nR::Float: effective resistance [Ω]\nL::Float: effective inductance [H]\n\nTheory\n\nAn external network is often characterised by its Fault level and its X/R ratio. In particular the Fault Level is a measure of the strength of a network. It is the amount of apparent power that the network can supply when a three-phase bolted to ground fault is applied at the point of connection. From these values an effective resistance and inductance can be calculated. Typical values of X/R ratios are in the range of 0.5 to 1.5, for distribution networks. Transmission networks operating at higher voltages tend to have higher X/R ratios.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.FilterDesign-Tuple{Any, Any, Any}","page":"References","title":"JEG.FilterDesign","text":"FilterDesign(Sr, fs, fltr; Vrms = 230, Vdc = 800, ΔILf_ILf = 0.15, ΔVCf_VCf = 0.01537)\n\nDescription\n\nDesigns the filter inductances and capacitances for the sources\n\nArguments\n\nSr::Float: rated 3 phase Apparent Power [VA]\nfs::Float:switching frequency\nfltr::String: topology \"LCL\", \"LC\", \"L\"\n\nKeyword Arguments\n\nVrms::Float: nominal AC rms voltage\nVdc::Float: nominal DC voltage\nΔILf_ILf::Float: current ripple ratio\nΔVCf_VCf::Float: voltage ripple ratio\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.Filtering-Tuple{ClassicalControls, Any, Any}","page":"References","title":"JEG.Filtering","text":"Filtering(Source::ClassicalControls, num_source, θ)\n\nDescription\n\nFirst order Low pass filter on voltage DQ0 components.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.FirstOrderLPF-NTuple{4, Any}","page":"References","title":"JEG.FirstOrderLPF","text":"FirstOrderLPF(fc, x, y, μ) - Low Pass Filter\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GenerateA-Tuple{NodeConstructor}","page":"References","title":"JEG.GenerateA","text":"GenerateA(self::NodeConstructor)\n\nReturns the A matrix by joining the individual sub-matrices together.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GenerateALoad-Tuple{NodeConstructor, Any}","page":"References","title":"JEG.GenerateALoad","text":"GenerateALoad(self::NodeConstructor, load_i)\n\nCreate the Atranload_l entry in the A matrix.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GenerateATrn-Tuple{NodeConstructor}","page":"References","title":"JEG.GenerateATrn","text":"GenerateATrn(self::NodeConstructor)\n\nCreate the A_tran entry in the A matrix.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GenerateATrnLoadC-Tuple{NodeConstructor, Any}","page":"References","title":"JEG.GenerateATrnLoadC","text":"GenerateATrnLoadC(self::NodeConstructor, load_i)\n\nCreate the Atranload_c entry in the A matrix.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GenerateATrnLoadL-Tuple{NodeConstructor, Any}","page":"References","title":"JEG.GenerateATrnLoadL","text":"GenerateATrnLoadL(self::NodeConstructor, load_i)\n\nCreate the Atranload_l entry in the A matrix.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GenerateB-Tuple{NodeConstructor}","page":"References","title":"JEG.GenerateB","text":"GenerateB(self::NodeConstructor)\n\nReturns the B matrix by joining the individual sub-matrices together.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GenerateC-Tuple{NodeConstructor}","page":"References","title":"JEG.GenerateC","text":"GenerateC(self::NodeConstructor)\n\nReturns the C matrix.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GenerateCM-NTuple{5, Any}","page":"References","title":"JEG.GenerateCM","text":"GenerateCM(num_sources, num_loads, S2L_p, S2S_p, L2L_p)\n\nReturns the constructed CM and the total number of connections.\n\nGets num_sources and num_loads to calculate the total number of elements. Depending on the probabilities S2L_p, S2S_p and L2L_p, the entries are then set in the CM matrix. After the entries have been set randomly, it is checked that all elements have at least one connection and that no subnets have been created.\n\nArguments\n\nnum_sources::Int: number of sources\nnum_loads::Int: number of loads\nS2L_p::Int: probability that a source is connected to a load\nS2S_p::Int: probability that a source is connected to a source\nL2L_p::Int: probability that a load is connected to a load\n\nReturn Values\n\ncntr::Int: number of connections\nCM::Matrix: connectivity matrix describing the connections in the grid\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GenerateD-Tuple{NodeConstructor}","page":"References","title":"JEG.GenerateD","text":"GenerateD(self::NodeConstructor)\n\nReturns the D matrix.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GetASource-Tuple{NodeConstructor, Any}","page":"References","title":"JEG.GetASource","text":"GetASource(self::NodeConstructor, source_i)\n\nCreate the A_src entry for a source in the A matrix.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GetASourceTrnC-Tuple{NodeConstructor, Any}","page":"References","title":"JEG.GetASourceTrnC","text":"GetASourceTrnC(self::NodeConstructor, source_i)\n\nCreate the Asrctrn_c entry in the A matrix.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GetASourceTrnL-Tuple{NodeConstructor, Any}","page":"References","title":"JEG.GetASourceTrnL","text":"GetASourceTrnL(self::NodeConstructor, source_i)\n\nCreate the Asrctrn_l entry in the A matrix.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GetActionIds-Tuple{NodeConstructor}","page":"References","title":"JEG.GetActionIds","text":"GetActionIds(self::NodeConstructor)\n\nCreates the State Vector for an related NodeConstructor and outputs it as a list of strings.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GetBSource-Tuple{NodeConstructor, Any}","page":"References","title":"JEG.GetBSource","text":"GetBSource(self::NodeConstructor, source_i)\n\nCreate the B_source entry for a source in the B matrix.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GetCSumCableNode-Tuple{Any, NodeConstructor}","page":"References","title":"JEG.GetCSumCableNode","text":"GetCSumCableNode(node_i, self::NodeConstructor)\n\nReturns the sum of the capacities at a node point.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GetCableStateIndices-Tuple{NodeConstructor, Any}","page":"References","title":"JEG.GetCableStateIndices","text":"GetCableStateIndices(self::NodeConstructor,cables)\n\nReturns all state indices for passed cables.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GetFltrDistr-Tuple{Any}","page":"References","title":"JEG.GetFltrDistr","text":"GetFltrDistr(num)\n\nCalculates the distribution of filters based on a Dirichlet distribution and the total num of filters.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GetLoadStateIndices-Tuple{NodeConstructor, Any}","page":"References","title":"JEG.GetLoadStateIndices","text":"GetLoadStateIndices(self::NodeConstructor,loads)\n\nReturns all state indices for passed loads.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GetLoadsDistr-Tuple{Any}","page":"References","title":"JEG.GetLoadsDistr","text":"GetLoadsDistr(num)\n\nCalculates the distribution of loads based on a Dirichlet distribution and the total num of loads.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GetSourceStateIndices-Tuple{NodeConstructor, Any}","page":"References","title":"JEG.GetSourceStateIndices","text":"GetSourceStateIndices(self::NodeConstructor,sources)\n\nReturns all state indices for passed sources.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GetStateIds-Tuple{NodeConstructor}","page":"References","title":"JEG.GetStateIds","text":"GetStateIds(self::NodeConstructor)\n\nCreates the State Vector for an related NodeConstructor and outputs it as a list of strings.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GetStateParameters-Tuple{NodeConstructor}","page":"References","title":"JEG.GetStateParameters","text":"GetStateParameters(self::NodeConstructor)\n\nCreates a Vector containing the related L or C Parameters for the states of a NodeConstructor.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GetSystem-Tuple{NodeConstructor}","page":"References","title":"JEG.GetSystem","text":"GetSystem(self::NodeConstructor)\n\nReturns the system matrices A, B, C and D.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.GetYBus-Tuple{NodeConstructor}","page":"References","title":"JEG.GetYBus","text":"GetYBus(self::NodeConstructor)\n\nReturns the Admittance Matrix of the power grid based on the CM matrix and the parameters.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.Learn-Tuple{Any, Any}","page":"References","title":"JEG.Learn","text":"hook = Learn(controllers, env, num_episodes = 1 hook=hook)\n\nDescription\n\nExecuted the given controllers in the environments for num_episodes. Fills thereby the hook. Here the RL agents are training and e.g. action noise is applied.\n\nArguments\n\ncontrollers::MultiController: Contains controllers and agents\nenv::ElectricGridEnv: mutable struct containing the environment.\nnum_episodes::Int: Number of episodes simulated.\nhook::DataHook: Stores the data to measure in a DataFrame.\n\nReturn Values\n\nhook::DataHook: Measured data.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.LoadSetup-Tuple{Any, Any}","page":"References","title":"JEG.LoadSetup","text":"LoadSetup(num_loads, total_gen; gen_load_ratio=6, random=nothing, Vrms=230)\n\nunder development\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.LuenbergerObserver-Tuple{ClassicalControls, Any}","page":"References","title":"JEG.LuenbergerObserver","text":"LuenbergerObserver(Source::ClassicalControls, num_source)\n\nDescription\n\nDiscrete time approximate deadbeat Luenberger observer operating in DQ0 frame\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.Measurements-Tuple{ClassicalControls}","page":"References","title":"JEG.Measurements","text":"Measurements(Source::ClassicalControls)\n\nDescription\n\nCalculates RMS quantities and Active and Reactive power for every classical source.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.MultiGainMatrixPar-NTuple{4, Any}","page":"References","title":"JEG.MultiGainMatrixPar","text":"K, v = MultiGainMatrixPar(A, C, λ, p)\n\nDescription\n\nFinds the Gain Matrix given the chosen eigenvalues for a multi input system.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.NewtonInterpolation-Tuple{Any, Any, Any}","page":"References","title":"JEG.NewtonInterpolation","text":"NewtonInterpolation(coef, x_data, x)\n\nDescription\n\nPerforms a Newton interpolation. Think of x as the point in time, and x_data as the points in time  where we know what values the function takes.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.Observability-Tuple{Any, Any}","page":"References","title":"JEG.Observability","text":"O, rank(O) = Observability(C, A)\n\nDescription\n\nFinds the observability matrix.\n\nReturn Values\n\nO: Observability matrix\nrank(O): rank of O\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.ObserverInitialiser-Tuple{ClassicalControls, Any}","page":"References","title":"JEG.ObserverInitialiser","text":"ObserverInitialiser(Source::ClassicalControls, ns)\n\nDescription\n\nInitialises the observers\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.OrnsteinUhlenbeck-Tuple{ClassicalControls}","page":"References","title":"JEG.OrnsteinUhlenbeck","text":"OrnsteinUhlenbeck(Source::ClassicalControls)\n\nDescription\n\nProduces an Ornstein Uhlenbeck process.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.PIController-NTuple{6, Any}","page":"References","title":"JEG.PIController","text":"PIController(Error_new, Error_Hist, Error_t, Kp, Ki, μ; bias = zeros(length(Error_new)))\n\nDescription\n\nGeneric PI controller.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.PQControlMode-Tuple{ClassicalControls, Any, Any}","page":"References","title":"JEG.PQControlMode","text":"PQControlMode(Source::ClassicalControls, num_source, pq0)\n\nDescription\n\nWrapper for simple grid following control. A controllable load on the real and imaginary power.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.PVControlMode-Tuple{ClassicalControls, Any, Any}","page":"References","title":"JEG.PVControlMode","text":"PVControlMode(Source::ClassicalControls, num_source, pq0)\n\nDescription\n\nWrapper for more elaborate grid following control. A controllable load on the real power and voltage magnitude.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.ParallelLoadImpedance-Tuple{Any, Any, Any}","page":"References","title":"JEG.ParallelLoadImpedance","text":"R, LC, X, Z = ParallelLoadImpedance(S, pf, vrms; fsys = 50, typesign = nothing)\n\nArguments\n\nS::Float: 3 phase Apparent Power [VA]\npf::Float: power factor. pf > 0 -> inductive load, pf < 0 -> capacitive load\nVrms::Float: Line to Neutral rms voltage of external network [V]\n\nKeyword Arguments\n\nfsys::Float: system frequency [Hz]\ntype_sign::String: \"L\" or \"C\" -> for purely capacitive or inductive loads\n\nReturn Values\n\nR::Float: resistance [Ω]\nL_C::Float: inductance [H] or capacitance [F]\nX::Float: reactance [Ω]\nZ::Complex: impedance [Ω]\n\nTheory\n\nConverts a Resistance-Inductance Load, or a Resistance-Capacitance Load from power to circuit values, where the components are placed in parallel.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.PhaseLockedLoop3ph-Tuple{ClassicalControls, Any}","page":"References","title":"JEG.PhaseLockedLoop3ph","text":"PhaseLockedLoop3ph(Source::ClassicalControls, num_source; ωn = 70, ξ = 0.35)\n\nDescription\n\nTuned 3 phase Phase Locked loop.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.RMS-Tuple{Any, Any}","page":"References","title":"JEG.RMS","text":"Description\n\nPer phase least squares calculation of fundamental rms signal\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.Ramp-Tuple{Any, Any, Any}","page":"References","title":"JEG.Ramp","text":"Ramp(final, μ, i; t_end = 0.02)\n\nDescription\n\nRamps up a signal.\n\nArguments\n\nfinal: the final value.\nμ: time step size [s].\ni: time step.\n\nKeyword Arguments\n\nt_end: when the final value should be reached [s].\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.RenderHookResults-Tuple{}","page":"References","title":"JEG.RenderHookResults","text":"RenderHookResults(; hook, \n                    states_to_plot = nothing, \n                    actions_to_plot = nothing ,\n                    episode = 1, \n                    power_p_inv = [], \n                    power_q_inv = [], \n                    power_p_poc = [], \n                    power_q_poc = [], \n                    v_mag_inv   = [], \n                    v_mag_cap   = [], \n                    i_mag_inv   = [], \n                    i_mag_poc   = [],\n                    freq        = [], \n                    angles      = [], \n                    i_sat       = [], \n                    i_err       = [], \n                    i_err_t     = [], \n                    v_sat       = [], \n                    v_err       = [], \n                    v_err_t     = [],\n                    plot_reward = false, \n                    plot_reference = false,\n                    vdc_to_plot = [],)\n\nKeyword Arguments\n\nepisode::Int: episode to plot\npower_p_inv::Vector{Int}: instantaneous real power at the terminals of the source [W]\npower_q_inv::Vector{Int}: instantaneousimaginary power at the terminals of the source [VAi]\npower_p_poc::Vector{Int}: instantaneousreal power at the point of connection of the source [W]\npower_q_poc::Vector{Int}: instantaneous imaginary power at the point of connection of the source [VAi]\nv_mag_inv::Vector{Int}: scaled L₂ norm in αβγ coordinates of the 3 phase voltages at the terminals of the source [V] \nv_mag_cap::Vector{Int}: scaled L₂ norm in αβγ coordinates of the 3 phase voltages at the filter capacitor of the source [V] \ni_mag_inv::Vector{Int}: scaled L₂ norm in αβγ coordinates of the 3 phase currents at the terminals of the source [A] \ni_mag_poc::Vector{Int}: scaled L₂ norm in αβγ coordinates of the 3 phase currents flowing into the external network of the source [A]\nfreq::Vector{Int}: angular velocity of the 3 phase voltages over the capacior nearest to the source [Hz]\nangles::Vector{Int}: relative positive phase sequence angles of the 3 phase voltages at the control nodes (measured with respect to the average angle over all the grid-forming sources) [degrees]\ni_sat::Vector{Int}: normalised and scaled L₂ norm in αβγ coordinates of the degree of nonlinearity (or anti-windup) of the current controller [V]\ni_err::Vector{Int}: L₂ norm in αβγ coordinates of the current error signal (measured current subtracted from reference current in DQ0 coordinates) [A]\ni_err_t::Vector{Int}: L₂ norm in αβγ coordinates of the integrated current error signal [As]\nv_sat::Vector{Int}: normalised and scaled L₂ norm in αβγ coordinates of the degree of nonlinearity (or anti-windup) of the voltage controller [A]\nv_err::Vector{Int}: L₂ norm in αβγ coordinates of the voltage error signal (measured voltage subtracted from reference voltage in DQ0 coordinates) [V]\nv_err_t::Vector{Int}: L₂ norm in αβγ coordinates of the integrated voltage error signal [Vs]\n\nNote\n\nFor quantities denoted by \"...mag...\" for balanced symmetrical networks in steady state this quantity equals the root-mean-square (rms) of the signal.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SampleCable-Tuple{Any}","page":"References","title":"JEG.SampleCable","text":"SampleCable()\n\nSample parameters for the cable.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SampleFilterL-Tuple{Any}","page":"References","title":"JEG.SampleFilterL","text":"SampleFilterL()\n\nSample parameters for the L filter.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SampleFilterLC-Tuple{Any}","page":"References","title":"JEG.SampleFilterLC","text":"SampleFilterLC()\n\nSample parameters for the LC filter.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SampleFilterLCL-Tuple{Any}","page":"References","title":"JEG.SampleFilterLCL","text":"SampleFilterLCL()\n\nSample parameters for the LCL filter.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SampleLoadC-Tuple{Any, Any}","page":"References","title":"JEG.SampleLoadC","text":"SampleLoadC()\n\nSample parameters for the C load.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SampleLoadL-Tuple{Any, Any}","page":"References","title":"JEG.SampleLoadL","text":"SampleLoadL()\n\nSample parameters for the L load.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SampleLoadLC-Tuple{Any, Any}","page":"References","title":"JEG.SampleLoadLC","text":"SampleLoadLC()\n\nSample parameters for the LC load.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SampleLoadR-Tuple{Any, Any}","page":"References","title":"JEG.SampleLoadR","text":"SampleLoadR()\n\nSample parameters for the R load.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SampleLoadRC-Tuple{Any, Any}","page":"References","title":"JEG.SampleLoadRC","text":"SampleLoadRC()\n\nSample parameters for the RC load.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SampleLoadRL-Tuple{Any, Any}","page":"References","title":"JEG.SampleLoadRL","text":"SampleLoadRL()\n\nSample parameters for the RL load.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SampleLoadRLC-Tuple{Any, Any}","page":"References","title":"JEG.SampleLoadRLC","text":"SampleLoadRLC()\n\nSample parameters for the RLC load.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SampleSource-Tuple{Any, Any}","page":"References","title":"JEG.SampleSource","text":"default source settings\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SetConnection-Tuple{Any, Any, Any}","page":"References","title":"JEG.SetConnection","text":"SetConnection(cntr, x, p)\n\nSets x to zero or to the value of the counter as a function of p and increases it as well.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SetupAgents","page":"References","title":"JEG.SetupAgents","text":"SetupAgents(env, custom_agents)\n\nDescription\n\nInitialises up the agents that will be controlling the electrical network. It depends on the control_type and mode in the parameter dict. Handles to connect the different controllers to the correcponding sources represended by there indices (for states and actions).\n\nArguments\n\nenv::ElectricGridEnv: mutable struct containing the environment.\ncustom_agents::Dict{Agent}: Dict of Agents. The key is used as name in the MultiController.\n\nReturn Values\n\nMulti_Agent::MultiController: the struct containing the initialised agents\n\n\n\n\n\n","category":"function"},{"location":"references/#JEG.SetupMG-Tuple{Any, Any}","page":"References","title":"JEG.SetupMG","text":"SetupMG(num_sources, num_cables; random=nothing, avg_pwr=200e3, Vrms=230)\n\nunder development\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.Simulate-Tuple{Any, Any}","page":"References","title":"JEG.Simulate","text":"hook = Simulate(controllers, env, num_episodes = 1 hook=hook)\n\nDescription\n\nExecuted the given controllers in the environments for num_episodes. Fills thereby the hook. In case of RL agents deterministic actions are chosen, e.g., no action noise is used.\n\nArguments\n\ncontrollers::MultiController: Contains controllers and agents\nenv::ElectricGridEnv: mutable struct containing the environment.\nnum_episodes::Int: Number of episodes simulated.\nhook::DataHook: Stores the data to measure in a DataFrame.\n\nReturn Values\n\nhook::DataHook: Measured data.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SourceInitialiser-NTuple{4, Any}","page":"References","title":"JEG.SourceInitialiser","text":"SourceInitialiser(env, Source, modes, source_indices)\n\nDescription\n\nInitialises all of the sources with droop coefficients and proportional and integral gains.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SourceInterface-Tuple{ClassicalPolicy, ElectricGridEnv}","page":"References","title":"JEG.SourceInterface","text":"SourceInterface(ClassicalPolicy, ElectricGridEnv)\n\nDescription\n\n\"Measures\" or \"Observes\" the relevant quantities necessary for control.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SourceSetup-Tuple{Any}","page":"References","title":"JEG.SourceSetup","text":"under development\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.StepMode-Tuple{ClassicalControls, Any}","page":"References","title":"JEG.StepMode","text":"StepMode(Source::ClassicalControls, num_source; t_end = 0.04)\n\nDescription\n\nOpen loop control. Produces 3 stepped signals.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SwingMode-Tuple{ClassicalControls, Any}","page":"References","title":"JEG.SwingMode","text":"SwingMode(Source::ClassicalControls, num_source; t_end = 0.04)\n\nDescription\n\nOpen loop control. Produces 3 phase sinusoidal signals.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SwitchRows!-Tuple{Any, Any, Any}","page":"References","title":"JEG.SwitchRows!","text":"SwitchRows!(A, row_1, row_2)\n\nDescription\n\nSwitches rows and columns of a matrix\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SynchronverterMode-Tuple{ClassicalControls, Any}","page":"References","title":"JEG.SynchronverterMode","text":"SynchronverterMode(Source::ClassicalControls, num_source; pq0_ref = [Source.P[num_source]; Source.Q[num_source]], t_end = 0.04, mode = 2)\n\nDescription\n\nWrapper for enhanced grid forming control.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.ThirdOrderIntegrator-Tuple{Any, Any, Any}","page":"References","title":"JEG.ThirdOrderIntegrator","text":"ThirdOrderIntegrator(y_i, μ, u)\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.VoltageControlMode-Tuple{ClassicalControls, Any}","page":"References","title":"JEG.VoltageControlMode","text":"VoltageControlMode(Source::ClassicalControls, num_source; t_end = 0.04)\n\nDescription\n\nClosed loop voltage control with an inner current loop. Produces 3 phase sinusoidal  voltage signals over the filter capacitor. \n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.VoltageController-Tuple{ClassicalControls, Any, Any, Any}","page":"References","title":"JEG.VoltageController","text":"VoltageController(Source::ClassicalControls, num_source, θ, ω; Kb = 1)\n\nDescription\n\nOuter voltage control with anti-windup.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.VoltagePILoopShaping-Tuple{ClassicalControls, Any}","page":"References","title":"JEG.VoltagePILoopShaping","text":"VoltagePILoopShaping(Source::ClassicalControls, num_source)\n\nDescription\n\nTuning of proportional and integral gain for outer voltage controller.\n\n\n\n\n\n","category":"method"},{"location":"references/#ReinforcementLearningBase.reset!-Tuple{ElectricGridEnv}","page":"References","title":"ReinforcementLearningBase.reset!","text":"reset!(env)\n\nResets the environment. The state is set to x0, the time to t0, reward to zero and done to false.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.ClassicalControls","page":"References","title":"JEG.ClassicalControls","text":"ClassicalControls\n\nDescription\n\nMutable struct containing all of the variables and properties necessary to define any  classical controller\n\n\n\n\n\n","category":"type"},{"location":"references/#JEG.ClassicalPolicy","page":"References","title":"JEG.ClassicalPolicy","text":"ClassicalPolicy()\n\nDescription\n\nThe policy which is called when a classical controller is required.\n\n\n\n\n\n","category":"type"},{"location":"references/#JEG.ElectricGridEnv-Tuple{Any}","page":"References","title":"JEG.ElectricGridEnv","text":"env(action)\n\nDescription\n\nBasic function to interact with an RL agent or other controller. Takes the action and evolvs the system defined by the linear state-space system using that action.\n\nKeyword Arguments\n\naction::Vector: Action which is applied to the env. One per source per phase. Will be   multiplied with vdc and can be interpreted as modulation index.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.ElectricGridEnv-Tuple{}","page":"References","title":"JEG.ElectricGridEnv","text":"ElectricGridEnv(...)\n\nDescription\n\nReturns an environment consisting of an electrical power grid as control plant, which can interact via this interface with a reinforcement learing agent from https://juliareinforcementlearning.org/\n\nArguments\n\nKeyword Arguments\n\nmaxsteps::Int: the number of time steps that the simulation is run.\nts::Float: Sampling time by which the environment is evolved per step.\naction_space::Space: Defines the valide space per action.\nstate_space::Space: Defines the valide space per state. Default is [-1, 1] since the   states of the env will be normalized.\nprepare_action::function(env::ElectricGridEnv): Function to adjust, change, prepare the actions   before they are applied to the env during a step(). Per default it returns the action   without changes.\nfeaturize::function(x:Vector, t:Float; env::ElectricGridEnv, name::String): Function to adjust  the state before it is returned by the env. For example here  reference values can be added to provide the to an RL agent or other feature engineering  to improve the learning.\nreward_function::function(env::ElectricGridEnv, name::String) ): Function to define the reward   for a (named) policy. Return 0 per default.\nCM::Matrix: Conectivity matrix to define the structure of the electric power grid   (for more details see NodeConstructor)\nnum_sources::Int: Number of sources in the electric power grid\nnum_loads::Int: Number of loads in the electric power grid\nparameter::Dict: Dictonary to define the parameterof the grid. Entries can be \"grid\",   \"source\", \"load\", \"cable\". Here, e.g. the electric components are defined.\nx0::Vector: Initial states which will be used in reset!().\nt0::Float: Initial time where the env starts from simulating.\nstate_ids::Vector{String}: IDs of the states. Can be used for plotting or collecting   trajectories during a simulation with the DataHook.\nconvert_state_to_cpu::Bool: Flag if the states are converted to cpu if calculated one   gpu before\nuse_gpu::Bool: Flag if the simulation is done on gpu (if possible).\nreward::Float: Reward which the action achieved, applied in the env.\naction::Vector{Float}: Action which is applied to the env.\naction_ids::Vector{String}: IDs of the actions. Can be used for plotting or collecting   trajectories during a simulation with the DataHook.\nstate_action_delay::Int: Specifies the number of simulation steps it is delayed from   giving an action to the env to when it is applied to the plant.\nt_end::Float: Spezifies the end time of an episode. If defined it overwrites maxsteps.\nverbosity::Int: Deinfes the level of how much information (warnings, info,...) is   printed to the console (0 - nothing, 1 - warn, 2 - debug(warn, info,...)).\nstate_ids_RL::Vector{String}: State ids which are given to RL agents.\naction_ids_RL::Vector{String}: Action ids which are given to RL agents.\n\nReturn Values\n\nMulti_Agent::MultiController: (optional)\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.MultiController-Tuple{Any, Any}","page":"References","title":"JEG.MultiController","text":"MultiController(agents, action_ids)\n\nDescription\n\nConstructs the MultiController providing different subfunctions mappen the correct env indices to the corresponding controllers and agents.\n\nArguments\n\nagents::Dict(NamedPolicy, ids): Contains all the agents as named policys with there   corresponding ids.\naction_ids::Vector{String}: All env action indices.\n\nReturn Values\n\nMulti_Agent::MultiController: the struct containing the initialised agents\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.NodeConstructor-Tuple{}","page":"References","title":"JEG.NodeConstructor","text":"NodeConstructor(;\n    num_sources,\n    num_loads,\n    CM = nothing,\n    parameters = nothing,\n    S2S_p = 0.1,\n    S2L_p = 0.8,\n    L2L_p = 0.3,\n    ts = 10000,\n    verbosity = 0\n    )\n\nCreate a mutable struct NodeConstructor, which serves as a basis for the creation of an energy grid: num_sources corresponse to the amount of sources and num_loads is the amount of loads in the grid. CM is the connection matrix which indicates how the elements in the grid are connected to each other. To specify the elements of the net in more detail, values for the elements can be passed via parameters. If no connection matrix is entered, it can be generated automatically. S2S_p is the probability that a source is connected to another source and S2L_p is the probability that a source is connected to a load.\n\n\n\n\n\n","category":"method"},{"location":"references/#JEG.SolarModule","page":"References","title":"JEG.SolarModule","text":"Basic example for a diffrent source \n\n\n\n\n\n","category":"type"},{"location":"environment/#ElectricGridEnv-Demo","page":"Configuring the Environment","title":"ElectricGridEnv Demo","text":"","category":"section"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"This notebook is intended to show the functionality of the ElectricGridEnv which creates an environment for simulation of power-electronic driven microgrids with ad-hoc data generation. It can be used to to train and test reinforcement learing agents (e.g., from  https://juliareinforcementlearning.org/). These agents can learn to handle different control tasks and can be compared to classical control approaches.","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"The dynmaic bahaviour of the envorinment is simulated using linear state-space systems. It interacts step-wise with the agent/controller like shown in the figure below. Based on the input/action u at timestep k the state x is calculated.","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"(Image: )","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"To use the JEG tool the JEG package has to be loaded:","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"using JEG","category":"page"},{"location":"environment/#Simplest-initialisation","page":"Configuring the Environment","title":"Simplest initialisation","text":"","category":"section"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"The easiest way to initialize an environment is as follows:","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"env = ElectricGridEnv(num_sources = 2, num_loads = 1)","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n******************************************************************************","category":"page"},{"location":"environment/#ElectricGridEnv","page":"Configuring the Environment","title":"ElectricGridEnv","text":"","category":"section"},{"location":"environment/#Traits","page":"Configuring the Environment","title":"Traits","text":"","category":"section"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"Trait Type Value\nNumAgentStyle ReinforcementLearningBase.SingleAgent()\nDynamicStyle ReinforcementLearningBase.Sequential()\nInformationStyle ReinforcementLearningBase.ImperfectInformation()\nChanceStyle ReinforcementLearningBase.Stochastic()\nRewardStyle ReinforcementLearningBase.StepReward()\nUtilityStyle ReinforcementLearningBase.GeneralSum()\nActionStyle ReinforcementLearningBase.MinimalActionSet()\nStateStyle ReinforcementLearningBase.Observation{Any}()\nDefaultStateStyle ReinforcementLearningBase.Observation{Any}()","category":"page"},{"location":"environment/#Is-Environment-Terminated?","page":"Configuring the Environment","title":"Is Environment Terminated?","text":"","category":"section"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"No","category":"page"},{"location":"environment/#State-Space","page":"Configuring the Environment","title":"State Space","text":"","category":"section"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"ReinforcementLearningBase.Space{Vector{IntervalSets.ClosedInterval{Float64}}}(IntervalSets.ClosedInterval{Float64}[-1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0])","category":"page"},{"location":"environment/#Action-Space","page":"Configuring the Environment","title":"Action Space","text":"","category":"section"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"ReinforcementLearningBase.Space{Vector{IntervalSets.ClosedInterval{Float64}}}(IntervalSets.ClosedInterval{Float64}[-1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0])","category":"page"},{"location":"environment/#Current-State","page":"Configuring the Environment","title":"Current State","text":"","category":"section"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"This creates an environment consisting of an electrical power grid with two sources num_sources = 2 (which could be for example an inverter fed by a PV plant or a wind turbine or battery) - supplying one load num_sources = 1. An easy exemplary example is shown in the figure below, where a load (household) is supplied by 2 sources (inverters, fed PV plant and wind turbine) via two transmission lines.","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"(Image: )","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"For better visuablilty an exemplary shaded electircal circut in the background is displayed as single phase diagram. (By default a three-phase four wire system is created). If it is not defined during the initialization of the env, all parameters (connections between the different sources and loads, parameters of the electric components,...) are drawn randomly, while a few are set to fixed value per default. One of the latter would be for example the stepsize ts. After the initialization a step-wise interaction with the environment is possible.  As can be seen in the first picture, an action can be selected and the env can be executed with it.  Based on that action u_k and the internal state-space system (defined depending on the electric components - for more information about the odernary differential equation,... see NodeConstructorDEMO.ipynb) the system is evolved for one timestep and the new states `xk+1` of the system are calulated.","category":"page"},{"location":"environment/#States-and-actions","page":"Configuring the Environment","title":"States and actions","text":"","category":"section"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"First, the current states of the environment are checked:","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"env.state","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"30-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n ⋮\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"If the state is not zero, but should be in the beginning, the reset method can be used which sets the state to the internally defined x0 (which consists of zeros per default). If we do not want to not start from zero, we could set x0 in the initialisation of the env:","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"using ReinforcementLearning\nenv.x0 = 0.1 * ones(length(env.state_space))\nreset!(env)\nenv.state","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"30-element Vector{Float64}:\n 0.1\n 0.1\n 0.1\n 0.1\n 0.1\n 0.1\n 0.1\n 0.1\n 0.1\n 0.1\n ⋮\n 0.1\n 0.1\n 0.1\n 0.1\n 0.1\n 0.1\n 0.1\n 0.1\n 0.1","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"To interact with the env, it has to be figured out how many actions are needed. Therefore the length of the action space can be checked:","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"n_a = length(env.action_space)","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"6","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"The six action requested by the environment belong to the 2 sources. Since per default the env produces a three-phase system we need one action per phase per source -> 6 actions. To excite the env by an action the following command can be used:","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"env([0.2, 0.2, 0.2, 0.3, 0.3, 0.3])","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"30-element Vector{Float64}:\n -0.16394393819718883\n  0.008632257605152691\n  2.0598878480930146e-8\n -0.1605061258652815\n  0.027306112731665413\n -0.0016519374537311848\n -0.001854826977574919\n  0.0002007141020688965\n  0.031641836651051955\n  0.13796560159583626\n  ⋮\n  0.00863225760515267\n  2.0598878527674185e-8\n -0.1605061258652815\n  0.027306112731665506\n -0.0016519374537312126\n -0.001854826977574919\n  0.0002007141020688686\n  0.031641836651051844\n  0.13796560159583626","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"Here, the first source got an action of 0.2 to all three phases, while the second source got an action of 0.3 to all three phases. As can be seen, the states have changed from 0.1 to different values. To get a little bit more intuition about the different states, the state_ids can be investigated:","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"env.state_ids","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"30-element Vector{String}:\n \"source1_i_L1_a\"\n \"source1_v_C_filt_a\"\n \"source1_v_C_cables_a\"\n \"source2_i_L1_a\"\n \"source2_v_C_cables_a\"\n \"cable1_i_L_a\"\n \"cable2_i_L_a\"\n \"cable3_i_L_a\"\n \"load1_v_C_total_a\"\n \"load1_i_L_a\"\n ⋮\n \"source1_v_C_filt_c\"\n \"source1_v_C_cables_c\"\n \"source2_i_L1_c\"\n \"source2_v_C_cables_c\"\n \"cable1_i_L_c\"\n \"cable2_i_L_c\"\n \"cable3_i_L_c\"\n \"load1_v_C_total_c\"\n \"load1_i_L_c\"","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"The labels define to which source the state belongs and what it is about.  For example the first state is called \"source1_i_L1_a\". That tells, it belongs to the first source (in the picture above the PV plant) and represents the current i through the incductor L1 of phase a. For example, this information can be used to control the current through the filter inductance (or to learn this control task).","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"An example for a single phase 3 Bus grid consisting of 2 sources (LC and LCL filter), 3 cables and 1 RLC load is shown in the following figure highligthing some of the defineable parameters and states. This example only shows the equivalent electrical circuit diagramm but is similar to the example with the PV, windturbine and electric car. The only difference here is that the two sources are connected, too. ","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"(Image: )","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"A few states are labeled in red, while a few parameters defined in the parameter dict are marked in green.","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"env.state_space","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"Space{Vector{IntervalSets.ClosedInterval{Float64}}}(IntervalSets.ClosedInterval{Float64}[-1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0  …  -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0, -1.0..1.0])","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"Since the state space of the env tells, that it ranges from -1.0..1.0, the current \"source1_i_L1_a\" through the filter inductor in the example is normalized by the maximal current allowed to flow through the inductor. If this parameter is not defined it it set per default based on the filter layout happening in the env.","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"All (technical) parameters needed for the simulation are defined in the parameter dict (for more detailed information see below and NodeConstructor_DEMO.ipynb). It can be investigated by:","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"env.nc.parameters\n","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"Dict{Any, Any} with 4 entries:\n  \"source\" => Any[Dict{Any, Any}(\"L1\"=>0.00170766, \"C\"=>3.08246e-5, \"mode\"=>\"Sy…\n  \"grid\"   => Dict{Any, Any}(\"f_grid\"=>50, \"Δfmax\"=>0.005, \"fs\"=>10000.0, \"proc…\n  \"load\"   => Any[Dict{Any, Any}(\"Z\"=>8.64561-6.22694im, \"C\"=>0.000255711, \"L\"=…\n  \"cable\"  => Any[Dict{Any, Any}(\"Cb\"=>4.0e-7, \"Lb\"=>0.000264, \"Rb\"=>0.722, \"C\"…","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"The limit of the filter inductor current can be found using:","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"env.nc.parameters[\"source\"][1][\"i_limit\"]","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"139.15602558819927","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"Which returns the current limit (belonging to the inductor) of source one. The voltage limit for normalization is depending on the filter capacitor and calulated - if not defined - based on the capacitance. The same concept holds for the cables and loads (parametrization can be found in the parameter dict, too).","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"Since the action space is defined in a range -1.0..1.0, the actions are \"normalized\" by the DC-link voltage of the specific source.  In the simulation the chosen action is multiplied by half of the DC-link voltage (and can be interpreted as modulation index in an electrical engineering context). The DC-link voltage can be found in (or set via) the parameter dict, too:","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"env.nc.parameters[\"source\"][1][\"vdc\"]","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"800","category":"page"},{"location":"environment/#Parameters","page":"Configuring the Environment","title":"Parameters","text":"","category":"section"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"The wanted setting of the simulation can be adjusted using the parameter dict.  The most important parts will be investigated in the following. Like already shown above the parameter dict splits up into different parts describing different sections of the grid: gird, source, load, cable.","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"Now the most important parts of the parameter dict are investigated in more detail.","category":"page"},{"location":"environment/#Grid","page":"Configuring the Environment","title":"Grid","text":"","category":"section"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"Defines the basic setting of the whole electrical power grid. The moste important parameters are:","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"\"f_grid\": grid frequency (frequency of the sine wave) (default: 50 Hz)\n\"phases\": number of phases in the electric power grid (exclusive neutral). (default: 3)\n\"fs\": sample frequency of the simulation. Every step the environment if simulated 1/fs s forward (default: 10 kHz)\n\"v_rms\": root mean square value of the basic grid voltage (default: 230 V)\n...","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"env.nc.parameters[\"grid\"]","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"Dict{Any, Any} with 9 entries:\n  \"f_grid\"        => 50\n  \"Δfmax\"         => 0.005\n  \"fs\"            => 10000.0\n  \"process_start\" => 0.04\n  \"phase\"         => 3\n  \"ramp_end\"      => 0.04\n  \"ΔEmax\"         => 0.05\n  \"pwr\"           => 85000.0\n  \"v_rms\"         => 230","category":"page"},{"location":"environment/#Source","page":"Configuring the Environment","title":"Source","text":"","category":"section"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"A selection of the most important parameters that can be defined and configured via the parameter dict is given in the following:","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"\"pwr\": maximum aparent power of the source (default: random)\n\"source_type\": type of the electric component sitting on the DC side, e.g. ideal (constant vdc), PV,... (default: ideal)\n\"control_type\": defines whether the source is classically controlled or RL controlled (default = \"classic\")\n\"mode\": allows to specify which control mode the source (default = \"Droop\", and classic controltype) (for more information, see ClassicControllers_Notebook.iypnb)\n\"vdc\": DC-link voltage, fixed if \"source_type\" is ideal (drawn random U[690, 800] V), otherwise drawn from function\n\"fltr\": Filter type L, LC, LCL\n\"i_limit\": maximal allowed current flowing through the inductor(s) (default: calculated based on filter parameters)\n\"v_limit\": maximal allowed voltage across the capacitor (default: calculated based on filter parameters).\n...","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"env.nc.parameters[\"source\"][1]","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"Dict{Any, Any} with 28 entries:\n  \"L1\"           => 0.00170766\n  \"C\"            => 3.08246e-5\n  \"mode\"         => \"Synchronverter\"\n  \"fltr\"         => \"LC\"\n  \"pwr\"          => 40000.0\n  \"source_type\"  => \"ideal\"\n  \"R_C\"          => 2.48102\n  \"std_asy\"      => 10000.0\n  \"σ\"            => 0.0\n  \"i_limit\"      => 139.156\n  \"v_rip\"        => 0.01537\n  \"v_δ_set\"      => 0.0\n  \"vdc\"          => 800\n  \"τv\"           => 0.002\n  \"k\"            => 0\n  \"control_type\" => \"classic\"\n  \"v_pu_set\"     => 1.0\n  \"τf\"           => 0.002\n  \"i_rip\"        => 0.15\n  ⋮              => ⋮","category":"page"},{"location":"environment/#Load","page":"Configuring the Environment","title":"Load","text":"","category":"section"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"Defines passive loads which can be pluged/connected to the grid. All combinations of the passive components of a resistor, inductor and capacitor (\"impedance\") can be chosen:","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"\"impedance\": type/circuit of the load (can be something out of [RLC, RL, RC, LC, R, L, C]). Components will be connected in parallel (default: random)\n\"pwr\": apparant power of drawn from the load assuming fixed vrms grid voltage and frequency and the number of phases (see parameters of \"grid\")\n\"pf\": power factor resulting from chosen parameters\n\"Z\": impedance resulting from chosen parameters\n\"R\": load resistance\n...","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"env.nc.parameters[\"load\"]","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"1-element Vector{Any}:\n Dict{Any, Any}(\"Z\" => 8.645614985778817 - 6.226943873467353im, \"C\" => 0.00025571060022957864, \"L\" => 0.12491902487968094, \"R\" => 13.130527865555832, \"pwr\" => 14894.91016754301, \"pf\" => -0.811440822661242, \"impedance\" => \"RLC\")","category":"page"},{"location":"environment/#Cable","page":"Configuring the Environment","title":"Cable","text":"","category":"section"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"The cables are modelled using PI-models like shown in the figure above. If no parameters are defined they are chosen based on the power flowing through the cable.","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"\"len\": length of the cable (default: random [1m, 1km])\n\"i_limit\": mamimal allowed current flowing through the inductor (default: calculated based on power flow and inductance)\n\"v_limit\": since the capacitance it added to the one (if) defined in the source, the limit for the voltage can be found in the source parameter dict\n\"Cb\": cable capacity coatings (default: 0.4 µF)\n\"Lb\": cable operating inductor (default: 0.264 mH)\n\"Rb\": cable AC resistor (default: 0.722 Ohm)\n\"C\": cable capacity (default: \"len\"*\"Cb\")\n\"L\": cable inductance (default: \"len\"*\"Lb\")\n\"R\": cable resistance (default: \"len\"*\"Rb\")","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"env.nc.parameters[\"cable\"]","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"3-element Vector{Any}:\n Dict{Any, Any}(\"Cb\" => 4.0e-7, \"Lb\" => 0.000264, \"Rb\" => 0.722, \"C\" => 0.0004, \"i_limit\" => 1.0e13, \"len\" => 1.0, \"L\" => 0.00025, \"R\" => 0.208)\n Dict{Any, Any}(\"Cb\" => 4.0e-7, \"Lb\" => 0.000264, \"Rb\" => 0.722, \"C\" => 0.0004, \"i_limit\" => 1.0e13, \"len\" => 1.0, \"L\" => 0.00025, \"R\" => 0.208)\n Dict{Any, Any}(\"Cb\" => 4.0e-7, \"Lb\" => 0.000264, \"Rb\" => 0.722, \"C\" => 0.0004, \"i_limit\" => 1.0e13, \"len\" => 1.0, \"L\" => 0.00025, \"R\" => 0.208)","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"For all information about the parameters which can be defined investigate the parameter dict itself or have a look into the documentation (LINK).","category":"page"},{"location":"environment/","page":"Configuring the Environment","title":"Configuring the Environment","text":"The next step would be to interact with the env to run an experiment. To learn how to do this, see the Env_Interaction_DEMO.ipynb.","category":"page"},{"location":"nodeconstructor/#NodeConstructor-Demo","page":"The Nodeconstructor","title":"NodeConstructor Demo","text":"","category":"section"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"The NodeConstructor has the goal to convert the physical system, here the grid, into a mathematical model. This mathematical model can then be used to simulate the behavior of the network. This notebook addresses the following points:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Introduction to the NodeConstructor\nRepresentation of the physical grid\nBuilding of the state-space matrices","category":"page"},{"location":"nodeconstructor/#Introduction","page":"The Nodeconstructor","title":"Introduction","text":"","category":"section"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"(Image: Illustration of where the NodeConstructor is located)","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"The NodeConstructor is part of the enviroment (see graphic). Its function is to create the mathematical model of the grid to be simulated. The inputs for the NodeConstructor are the specifications of the grid, which will be discussed in more detail subsequently. Within the NodeConstructor, an ordinary differential equation (ODE) system is created based on the underlying physical models and properties of the individual components. Based on this ODE system, the necessary matrices can be extracted.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"In the following, we will discuss how the mathematical model of an electrical power grid can be generated using the NodeConstructor.","category":"page"},{"location":"nodeconstructor/#Modelling-a-physical-grid","page":"The Nodeconstructor","title":"Modelling a physical grid","text":"","category":"section"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"The following graphic shows a simple example grid:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"(Image: Illustration of a simple network and its electrical equivalent circuit diagram.)","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Two sources (wind turbine on the left and PV arrays on the right), as well as a load (exemplary of a household which is composed of various objects) can be seen in this. In addition, the sources are connected to the load via cables. For the sources, we assume that the voltage is provided by a DC link, so we can assume that the voltage can be modeled by a voltage source and a filter. Loads are divided into active loads, which, based on an internal function, can take power from the network, and passive loads, which are described by their resistive, capacitive and/or inductive components and thus dissipate a certain power. Cable modeling relies on the Pi equivalent circuit like depicted in the fiure below.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"If you abstract the above figure and insert the respective components according to the description, you get the following single-phase circuit:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"(Image: Abstraction of the previously presented example grid.)","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"With the help of this example, we will now discuss the derivation of a mathematical model and what information the NodeConstructor will later need to generate this model automatically.","category":"page"},{"location":"nodeconstructor/#Fundamentals-of-electrical-engineering","page":"The Nodeconstructor","title":"Fundamentals of electrical engineering","text":"","category":"section"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"If we annotate the above equivalent circuit, we get the following representation:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"(Image: Equivalent curcuit with annotations.)","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"In this, the components are annotated and the currents are noted with the technical flow direction. For the sake of clarity, the voltages are only indicated by green arrows, but have the same name as the corresponding component to which they are applied.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Based on the components within the equivalent circuit diagram, we can now construct the differential equations. Togehter with Kirchhoff's laws","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"$","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"\\begin{align}     \\sumk^n ik(t) &= 0,\\\n    \\sumk^n un(t) &= 0 \\end{align} $","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"and the component equations","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"$","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"\\begin{align}     u(t) &= R i(t),\\\n    i(t) &= C\\dot u(t),\\\n    u(t) &= L\\dot i(t). \\end{align} $","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"This gives the following equation system:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"$","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"\\begin{align}     \\text{M1:}\\;& 0 = u{in1}  - u{R11} - u{L11} - u{C11} - u{RC1}, \\tag{1}\\label{equ:1}\\\n    \\text{M2:}\\;& 0 = u{C11} + u{RC1} - u{Cb11},\\tag{2}\\label{equ:2}\\\n    \\text{M3:}\\;& 0 = u{Cb11} - u{Rb1} - u{Lb1} - u{Cb21},\\tag{3}\\label{equ:3}\\\n    \\text{M4:}\\;& 0 = u{RL} - u{LL}, \\tag{4}\\label{equ:4}\\\n    \\text{M5:}\\;& 0 = u{Cb22} + u{Rb2} + u{Lb2} - u{Cb12}, \\tag{5}\\label{equ:5}\\\n    \\text{M6:}\\;& 0 = u{Cb12} + u{R22} + u{L22} - u{C12} - u{RC2}, \\tag{6}\\label{equ:6}\\\n    \\text{M7:}\\;& 0 = u{RC2} + u{C12} + u{L12} + u{R12} - u{in2}, \\tag{7}\\label{equ:7}\\\n    \\text{N1:}\\;& 0 = i{11} - i{RC1} - i{Cb11} - i{Rb1}, \\tag{8}\\label{equ:8}\\\n    \\text{N2:}\\;& 0 = i{Rb1} - i{Cb21} - i{CL} - i{RL} - i{LL} - i{Cb22} + i{Rb2}, \\tag{9}\\label{equ:9}\\\n    \\text{N3:}\\;& 0 = i{22} - i{Rb2} - i{Cb21}, \\tag{10}\\label{equ:10}\\\n    \\text{N4:}\\;& 0 = i{12} - i{RC2} - i_{22}. \\tag{11}\\label{equ:11} \\end{align} $","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"For the sake of clarity, the time dependencies are omitted here. For node 2 the connected capacitances are summed up, because there are several capacitors connected in parallel, e.g.:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"\\begin{equation}     C{SL} = C{b1} + CL + C{b2} \\end{equation}","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"We then call this capacitor C_SL through which the current i_CSL flows and the voltage u_CSL is applied. Now we insert the component equations into the equations \\ref{equ:1} to \\ref{equ:11} and rearrange them,  so that an ODE system is obtained:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"\\begin{align}     \\dot i{11} &= \\frac{1}{L{11}} \\left( u{in1}  - R{11} i{11} - R{RC1} i{RC1} - u{C12} \\right), \\\n    \\dot u{C11} &= \\frac{1}{C{11}R{C11}} \\left(u{Cb11} - u{RC1} \\right), \\\n    \\dot i{Rb1} &= \\frac{1}{L{b1}} \\left( u{Cb11} - i{Rb1} R{b1} \\right),\\\n    \\dot i{LL} &= \\frac{1}{L{L}} u{CL}\\\n    \\dot i{Rb2} &= \\frac{1}{L{b2}} \\left( u{Cb12} - i{Rb2} R{b2} - u{Cb22}\\right),\\\n    \\dot i{22} &= \\frac{1}{L{22}} \\left( u{C12}  - i{22} (R{C2}+R{22}) - R{RC1} i{RC2} - u{Cb12} \\right), \\\n    \\dot i{12} &= \\frac{1}{L{12}} \\left( u{in2}  - i{12} (R{12} + R{RC1}) - R{RC1} i{C1} - u{C12} \\right), \\\n    \\dot u{Cb11} &= \\frac{1}{C{b1}} \\left(i{11} - i{Rb1} - \\frac{1}{R{C1}} u{Cb11} + \\frac{1}{R{C1}} u{C11}\\right)\\\n    \\dot u{CSL} &= \\frac{1}{C{SL}} \\left( i{Rb1} + i{Rb2} - \\frac{1}{R{L}} u{CSL} - i{LL} \\right)\\\n    \\dot u{Cb12} &= \\frac{1}{C{b2}} \\left(i{22} - i{Rb2}\\right).\\\n    \\dot u{C12} &= \\frac{1}{C{12}} \\left(i{12} - i{22}\\right).\\\n\\end{align}","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"These differential equations describe the system completely and could be solved for exampled using numerical solvers like Forward Euler or Runge-Kutta. ","category":"page"},{"location":"nodeconstructor/#Forming-the-system-matrices-from-the-ODEs","page":"The Nodeconstructor","title":"Forming the system matrices from the ODEs","text":"","category":"section"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"The differential equations found are now to be converted into the common state-space representation:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"\\begin{align}     \\dot{\\vec{x}}(t) &= \\mathbf{A} \\vec{x}(t) + \\mathbf{B} \\vec{u}(t)\\\n    \\vec{y}(t) &= \\mathbf{C} \\vec{x}(t) + \\mathbf{D} \\vec{u}(t) \\end{align}","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Since we are interested in how our grid evolves over time, the first equation is most relevant to our application. x(t) describes in general the state vector, dot x(t) the changes of this state vector. The change of the system is described on the one hand by the system dynamics, which is expressed by the matrix mathbfA and on the other hand by the input signals u(t) acting on the system combined with the matrix mathbfB.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"For our example, we can find the following state vector:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"\\begin{equation}     \\vec{x}(t) =      \\begin{pmatrix}         i{11} & u{C11} & u{Cb11}  & i{12} & u{C12} & i{22} & u{Cb12} & i{Rb1} & i{Rb2} & u{CSL} & i_{LL}     \\end{pmatrix}^\\top \\end{equation}","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"and the following input vector:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"\\begin{equation}     \\vec{u}(t) =      \\begin{pmatrix}         u{in1} & u{in2}     \\end{pmatrix}^\\top. \\end{equation}","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"It should be noted that the order of the states here is first sources, then cables and finally the loads. ","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"This leads for the investigated example to the following matrices:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"\\begin{equation}     \\mathbf{A} =      \\begin{pmatrix}         -\\frac{R{11}}{L{11}} & 0 & -\\frac{1}{L{11}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\n        0 & -\\frac{1}{C{11} R{C1}} & \\frac{1}{C{11} R{C1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\n        \\frac{1}{C{b1}} & \\frac{1}{C{b1} R{C1}} & -\\frac{1}{C{b1} R{C1}} & 0 & 0 & 0 & 0 & -\\frac{1}{C{b1}} & 0 & 0 & 0\\\n        0 & 0 & 0 & -\\frac{R{12} + R{C2}}{L{12}} & -\\frac{1}{L{12}} & \\frac{R{C2}}{L{12}} & 0 & 0 & 0 & 0 & 0\\\n        0 & 0 & 0 & \\frac{1}{C{12}} & 0 & -\\frac{1}{C{12}} & 0 & 0 & 0 & 0 & 0\\\n        0 & 0 & 0 & \\frac{R{C2}}{L{22}} & \\frac{1}{L{22}} & -\\frac{R{22} + R{C2}}{L{22}} & -\\frac{1}{L{22}} &0&0&0&0\\\n        0 & 0 & 0 & 0 & 0 & \\frac{1}{C{b2}} & 0 & 0 & -\\frac{1}{C{b2}} & 0 & 0\\\n        0 & 0 & \\frac{1}{L{b1}} & 0 & 0 & 0 & 0 & -\\frac{R{b1}}{L{b1}} & 0 & -\\frac{1}{L{b1}} & 0\\\n        0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{L{b2}} & 0 & -\\frac{R{b2}}{L{b1}} & -\\frac{1}{L{b2}} & 0\\\n        0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{C{SL}} & \\frac{1}{C{SL}} & -\\frac{1}{R{L} C{SL}} & -\\frac{1}{C{SL}}\\\n        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{L{L}} & 0\\\n    \\end{pmatrix} \\end{equation}","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"and","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"\\begin{equation}     \\mathbf{B} =      \\begin{pmatrix}         \\frac{1}{L{11}} & 0 \\\n        0 & 0 \\\n        0 & 0 \\\n        0 & \\frac{1}{L{12}} \\\n        0 & 0 \\\n        0 & 0 \\\n        0 & 0 \\\n        0 & 0 \\\n        0 & 0 \\\n        0 & 0 \\\n        0 & 0 \\\n    \\end{pmatrix} \\end{equation}","category":"page"},{"location":"nodeconstructor/#Solving-the-ODE-system","page":"The Nodeconstructor","title":"Solving the ODE system","text":"","category":"section"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Theory of exact discritization","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"We now have the state-space matrices we need to simulate the grid.  There are several tools to solve the differential equations. We use the ControlSystem package (Source), to be more precise the lsim() function. (AST Lecture 3, Slide A_d 47 folgende, Quelle)","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"using ControlSystemsBase\nusing LinearAlgebra\nusing PlotlyJS","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Next we define some the values of the components:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"# Source\nR = 1.1e-3\nL = 70e-6\nR_c = 7e-3\nC = 250e-6\n\n# Cable\nC_b = 1e-4/2\nL_b = 1e-4\nR_b = 1e-3\n\n# Load\nR_l = 100\nC_l = 1e-2\nL_l = 1e-2;","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Now we construct the matrices:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"A = zeros((11,11))\nA[1,1] = -R/L\nA[1,3] = -1/L\nA[2,2] = -1/(C*R_c)\nA[2,3] = 1/(C*R_c)\nA[3,1] = 1/C_b\nA[3,2] = 1/(R_c*C_b)\nA[3,3] = -1/(R_c*C_b)\nA[3,8] = -1/C_b\nA[4,4] = -(R+R_c)/L\nA[4,5] = -1/L\nA[4,6] = R_c/L\nA[5,4] = 1/C\nA[5,6] = -1/C\nA[6,4] = R_c/L\nA[6,5] = 1/L\nA[6,6] = -(R+R_c)/L\nA[6,7] = -1/L\nA[7,6] = 1/C_b\nA[7,9] = -1/C_b\nA[8,3] = 1/L_b\nA[8,8] = -R_b/L_b\nA[8,10] = -1/L_b\nA[9,7] = 1/L_b\nA[9,9] = -R_b/L_b\nA[9,10] = -1/L_b\n\nC_SL = C_b + C_l + C_b\n\nA[10,8] = 1/C_SL\nA[10,9] = 1/C_SL\nA[10,10] = -1/(R_l*C_SL)\nA[10,11] = -1/C_SL\nA[11,10] = 1/L_l;","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"B = zeros((11,2))\n\nB[1,1] = 1/L\nB[4,2] = 1/L;","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"C = Diagonal(ones(11));","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"D = 0;","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"We convert the matrices into the discrete time domain and create a discrete StateSpace object with the help of ControlSystems. This object can then represent the dynamics of the system for a given time interval using the function lsim().","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"ts = 1e-5\nAd = exp(A*ts)\nBd = A \\ (Ad - C) * B\nsys_d = StateSpace(Ad, Bd, C, D, ts);","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"ns = length(A[1,:]) # get num of states\nni = length(B[1,:]) # get num of inputs\nt = collect(0:ts:0.1)\nx0 = [0.0 for i = 1:ns]\nu = [230.0 for i = 1:length(t)]\nuu = [u for i = 1:ni ]\nuuu = mapreduce(permutedims, vcat, uu);","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"To use lsim() you need defined initial states x0, a time vector t and a input signal u. In our case we apply a jump to 230 V to the system.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"xout, _, _, _ = lsim(sys_d,uuu,t,x0=x0);","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"layout = Layout(xaxis_title=\"Time in µs\", yaxis_title=\"v_C / V\")\np = plot(t, xout[5,:], layout)","category":"page"},{"location":"nodeconstructor/#Automatic-generation-of-grids","page":"The Nodeconstructor","title":"Automatic generation of grids","text":"","category":"section"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"The creation of a grid always follows a certain pattern and can therefore be automated. In this way, you can avoid errors that may arise from the handwritten rearrangement of the equations. It is therefore obvious to write an automatism for the generation, which generates the matrices on the basis of input parameters.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"In this part of the notebook the above example shall be reproduced with the help of the NodeConstructor.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"An important point is the information about how the components are connected by which cable. To pass this information to the NodeConstructor we introduce the connection matrix (CM).","category":"page"},{"location":"nodeconstructor/#Connection-matrix","page":"The Nodeconstructor","title":"Connection matrix","text":"","category":"section"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"The connection matrix specifies how the elements of the grid are connected. In our grid there are two basic elements: sources and loads, which are then connected via cables.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"To get a better understanding of the CM, the CM of the previous example is shown below:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"From\\To Source 1 Source 2 Load 1\nSource 1 0 0 1\nSource 2 0 0 2\nLoad 1 -1 -2 0","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"The first column of the above matrix indicates which element we start from. The sources are considered first and after that the loads. The first row of the matrix indicates the elements to which we can connect. The number and order is identical to the first column.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Since our grid elements cannot be connected to themselves, there are always zeros on the main diagonal. In the second row of the table we can now identify the connections of the first source. This source is not connected to the second source but to the first load, which is why we find a \"1\" in this cell. We can read this entry as: \"Source 1 is connected to load 1 by cable 1\". In the third row of the table above, all connections are made from source 2, which is connected to load 1 via cable 2. The fourth line contains the connections of the 1 load. As shown before, it is connected to source 1 and source 2, but the entries have a negative sign. The negative sign indicates that the flow direction of the current is assumed to be negative. The sign of the entries is taken into account when constructing the DGLs, but has no influence on the subsequent current flow in the simulation. The matrix is antisymmetric, which means that we have a mirroring of the matrix along the main diagonal with the sign of the entries reversed.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"In Julia, this matrix then looks like this:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"CM = [ 0  0  1\n       0  0  2\n      -1 -2  0];","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"We now import the JuliaElectricGrid package:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"# Import the package\nusing JEG","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"To reproduce the above example exactly, the important parameters must be passed through the parameter dict: ","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"# Source\nR = 1.1e-3\nL = 70e-6\nR_c = 7e-3\nC = 250e-6\n\n# Cable\nC_b = 1e-4/2\nL_b = 1e-4\nR_b = 1e-3\n\n# Load\nR_l = 100\nC_l = 1e-2\nL_l = 1e-2;","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"parameters = Dict()\n\ngrid_properties = Dict()\ngrid_properties[\"fs\"] =  10e3\ngrid_properties[\"v_rms\"] = 230\ngrid_properties[\"phase\"] = 1;\nparameters[\"grid\"] = grid_properties\n\nsource1 = Dict()\nsource2 = Dict()\nsource_list = []\n\nsource1[\"fltr\"] = \"LCL\"\nsource1[\"R1\"] = R\nsource1[\"L1\"] = L\nsource1[\"C\"] = C\nsource1[\"R_C\"] = R_c\nsource1[\"R2\"] = R\nsource1[\"L2\"] = L\n\nsource2[\"fltr\"] = \"LC\"\nsource2[\"R1\"] = R\nsource2[\"L1\"] = L\nsource2[\"C\"] = C\nsource2[\"R_C\"] = R_c\npush!(source_list, source1, source2)\n\nparameters[\"source\"] = source_list\n\ncable = Dict()\ncable[\"R\"] = R_b\ncable[\"L\"] = L_b\ncable[\"C\"] = C_b\ncable_list = []\n\npush!(cable_list, cable, cable);\nparameters[\"cable\"] = cable_list\n\nload1 = Dict()\nload_list = []\n\nload1[\"impedance\"] = \"RLC\"\nload1[\"R\"] = R_l;\nload1[\"L\"] = L_l;\nload1[\"C\"] = C_l;\n\npush!(load_list, load1);\nparameters[\"load\"] = load_list;","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Now the NodeConstructor is called. In addition to the number of sources and loads, this also receives the CM and the parameter dict:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"S2_L1 = NodeConstructor(num_sources=2, num_loads=1, parameters=parameters, CM=CM);","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"With the function DrawGraph() the topology of the grid can now be displayed. Here, the color orange corresponds to a source and the color blue corresponds to a load.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"DrawGraph(S2_L1)","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"After the grid has been created it can be passed to the function GetSystem(), which then returns the matrices for the state space representation in the continous time domain.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"A, B, C, D = GetSystem(S2_L1);","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"We convert the matrices into the discrete time domain and create a discrete StateSpace object with the help of ControlSystems. This object can then represent the dynamics of the system for a given time interval using the function lsim().","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"ts = 1e-5\nAd = exp(A*ts)\nBd = A \\ (Ad - C) * B\nsys_d = StateSpace(Ad, Bd, C, D, ts);","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"To use lsim() you need defined initial states x0, a time vector t and a input signal u. In our case we apply a jump to 250 V to the system.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"ns = length(A[1,:]) # get num of states\nni = length(B[1,:]) # get num of inputs\nt = collect(0:ts:0.1)\nx0 = [0.0 for i = 1:ns]\nu = [250.0 for i = 1:length(t)]\nuu = [u for i = 1:ni ]\nuuu = mapreduce(permutedims, vcat, uu);","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"lsim() now solves the difference equations for the given time steps and we can observe how the states evolve.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"xout, _, _, _ = lsim(sys_d,uuu,t,x0=x0);","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Here we plot the voltage across the capacitor in the first source.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"layout = Layout(xaxis_title=\"Time in µs\", yaxis_title=\"v_C / V\")\np = plot(t, xout[2,:], layout)","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Manuell parameterization","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":".... Split up here .....","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Automatic generation","category":"page"},{"location":"nodeconstructor/#Automatic-generation-of-the-grids","page":"The Nodeconstructor","title":"Automatic generation of the grids","text":"","category":"section"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"An important feature is the creation of random node structures, where the parameters of the elements are chosen randomly. For fully connected structures, this can be generated, for example, using the parameters S2S_p, L2L_p and S2L_p. These indicate the connection probability of a source/load with any other source/load. If these parameters are set to 1, a fully connected node is generated.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"S2_L2_FC = NodeConstructor(num_sources=2, num_loads=2, S2S_p=1, S2L_p=1);","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Let's check the CM matrix.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"S2_L2_FC.CM","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"With a look into the parameter dict we also see that the parameters of the individual elements were randomly generated. The current policy for the sources is that an LC filter is always taken and the other filter types are chosen randomly.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"S2_L2_FC.parameters[\"source\"]","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"For larger networks, of course, only the number of sources and loads can be handed over, so that the network structures are created on the basis of the default values. An important point here is that it is ensured that no subnets are created. By default, it is ensured that each element of the network has at least one connection to the other components of the network, so that no subnetworks are created.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Internally, this is done by checking for connections for each element. If these are not present, they are automatically created. For smaller networks it is advisable to specify a CM matrix, because otherwise usually too many connections are made than necessary. However, this is no longer noticeable with more than 10+ elements.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"S5_L15 = NodeConstructor(num_sources=5, num_loads=15);","category":"page"},{"location":"nodeconstructor/#Three-phase-simulation","page":"The Nodeconstructor","title":"Three-phase simulation","text":"","category":"section"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Until now, only single-phase grids have been created with NodeConstructor. However, the default value for the number of phases is 3, so we will now also consider the three-phase variant.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"S5_L15 = NodeConstructor(num_sources=1, num_loads=2);","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"S5_L15.parameters[\"grid\"][\"phase\"]","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"A, B, C, D = GetSystem(S5_L15)\nts = 1e-4\nAd = exp(A*ts)\nBd = A \\ (Ad - C) * B\nsys_d = StateSpace(Ad, Bd, C, D, ts);","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"We then collect a few useful variables and set the time horizon for the simulation.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"ns = S5_L15.num_spp  # get num of states per phase\nni = S5_L15.num_sources # get num of inputs per phase\nt = collect(0:ts:1);","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Next we want to generate the three-phase input signals and repeat it for the number of sources:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"# Stepfunction\nu = sqrt(2)*[230, 0, -230]\nuu = repeat(u, inner=ni) .* ones(length(t))';","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"# Sin wave\nu = [230 * sin.(2*pi*t .- 2/3*pi*(i-1)) for i = 1:3]\nuu = transpose(hcat(repeat(u[1], inner=[1,ni]),repeat(u[2], inner=[1,ni]),repeat(u[3], inner=[1,ni])));","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Lets have a look:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"layout = Layout(xaxis_title=\"Time in µs\", yaxis_title=\"U in V\")\ninput = 1\n\nphase_a = scatter(x=t, y=uu[input+ni*0,:], mode=\"lines\", name=\"Phase A\")\nphase_b = scatter(x=t, y=uu[input+ni*1,:], mode=\"lines\", name=\"Phase B\")\nphase_c = scatter(x=t, y=uu[input+ni*2,:], mode=\"lines\", name=\"Phase C\")\n\nplot([phase_a, phase_b, phase_c], layout)","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Again, the discretized matrices can now be used to model the grid.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"x0 = [0.0 for i = 1:ns*3]\nxout, _, _, _ = lsim(sys_d,uu,t,x0=x0);","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Now a state can be selected and the corresponding trajectories can be plotted.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"state_list = GetStateIds(S5_L15)","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"state = 3\nstate_list = GetStateIds(S5_L15)\n\nlayout = Layout(xaxis_title=\"Time in µs\", yaxis_title=\"$(state_list[state]) in V\")\n\nphase_a = scatter(x=t, y=xout[state+ns*0,:], mode=\"lines\", name=\"Phase A\")\nphase_b = scatter(x=t, y=xout[state+ns*1,:], mode=\"lines\", name=\"Phase B\")\nphase_c = scatter(x=t, y=xout[state+ns*2,:], mode=\"lines\", name=\"Phase C\")\n\nplot([phase_a, phase_b, phase_c], layout)\n","category":"page"},{"location":"nodeconstructor/#Access-to-the-different-states","page":"The Nodeconstructor","title":"Access to the different states","text":"","category":"section"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"A way to get the different states of our NodeConstructor is to use the function GetStateIds().","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"state_list = GetStateIds(S5_L15)","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"The IDs created here are unique and can be used to access particular states. When creating the IDs, the sources are checked first in the order LCL, LC and then L. Then the cables are listed, which are also arranged in order. For the loads the order is RLC, LC, RL, L, RC, C and then R.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"For the three-phase case, the state IDs are repeated and the respective phase is added.","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"These can then be accessed as follows:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"state = 3\nprintln(state_list[state+ns*0])\nprintln(state_list[state+ns*1])\nprintln(state_list[state+ns*2])","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"Or:","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"state = \"source1_i_L1\"\nidx_of_state = findall(x->occursin(state, x), state_list)\nidx = idx_of_state","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"state = \"source1_i_L1_a\"\nidx_of_state = findall(x->occursin(state, x), state_list)\nidx = idx_of_state","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"The actions in the grid are also assigned unique IDs, here the sources are sorted in order. The IDs are output via the function GetActionIds().","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"GetActionIds(S5_L15)","category":"page"},{"location":"nodeconstructor/","page":"The Nodeconstructor","title":"The Nodeconstructor","text":"","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Consider the following code snippet","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using JEG\n\nenv =  ElectricGridEnv(num_sources = 1, num_loads = 1)\nMulti_Agent =  SetupAgents(env)\nhook =  Simulate(Multi_Agent, env)\nRenderHookResults(hook = hook)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"This is a minimal example of a full JuliaElectricGrid setup. After running you should see some output in your terminal, created by Ipopt, an EPL licensed library JEG is using. There should also appear a plot that looks like this: (Image: output of the minimal example)","category":"page"},{"location":"agents/#Train-an-RL-agent","page":"Set up Agents","title":"Train an RL agent","text":"","category":"section"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"This notebook will focus the following topics:","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"define reward function,\ndefine featurize function,\ntraining a single RL agent.","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"In this notebook a reinforcement learning agent is trained to control the current flowing through an inductor. It will be shown for an easy case how the agent can learn and be applied to an electrical power grid simulated with de JEG package.","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"The use case is shown in the figure below. This environment consists of a single phase electrical power grid with 1 source and 1 load connected via a cable.","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"(Image: )","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"First we define the environment with the configuration shown in the figure.  For more information on how to setup an environment see Env_Create_DEMO.ipynb.","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"RL is selected as control_type for the source (parameters[\"source\"][1][\"control_type\"]). Initially, any key can be used as the mode. Here, we choose the name my_ddpg.  This key is then used to link an agent to the source and its corresponding state and action ids. Based on these indices, the state that will be provided to the agent as well as the actions the agent outputs are passed to the appropriate places with the help of a MultiController. For further details please refer to Userguide -> MultiController.","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"using JEG\nusing ReinforcementLearning","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"Failed to start the Kernel. \n\n\nUnable to start Kernel 'Julia 1.8.2' due to connection timeout. \n\n\nView Jupyter <a href='command:jupyter.viewOutput'>log</a> for further details.","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"# calculate passive load for wanted setting / power rating\nR_load, L_load, X, Z = ParallelLoadImpedance(100e3, 1, 230)\n\n# define grid using CM\nCM = [0. 1.\n    -1. 0.]\n\n# Set parameters accoring graphic above\nparameters = Dict{Any, Any}(\n    \"source\" => Any[\n                    Dict{Any, Any}(\"pwr\" => 200e3, \"control_type\" => \"RL\", \"mode\" => \"my_ddpg\", \"fltr\" => \"L\"),\n                    ],\n    \"load\"   => Any[\n                    Dict{Any, Any}(\"impedance\" => \"R\", \"R\" => R_load, \"v_limit\"=>1e4, \"i_limit\"=>1e4),\n                    ],\n    \"grid\" => Dict{Any, Any}(\"phase\" => 1)\n)","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"To teach the agent that it should control the current in a certain way it needs information about which value the current shoud be (reference value) (->featurize) and how good the state is which was reached using the chosen action (-> reward).","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"Therefore, the reference value has to be defined.  Here we will use a constant value to keep the example simple. But since the the reference(t) function take the simulation time as argument, more complex, time dependent signals could be defined.","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"function reference(t)\n    return 1\nend","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"Afterwards the featurize() function, which gives the user the opportunity to modify a state before it gets passed to the agent, is defined.","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"It takes three arguments:","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"state contains all the state values that correspond to the source controlled by agent with key name\nenv references the environment\nname contains the key of the agent","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"The signal generated by the reference function is then added to the state for the agent my_ddpg. This will help the agent to learn because later we will define a reward that has maximum value if the measured current fits the reference value. The reference value has to be normalized in an appropirate way that it fits to the range of the normalized states.","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"Additionally more signals could be added here to enhance the learning process.","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"As stated before, state already contains all state values of the source the agent with key name should control. However, the environment maintains a lot more states than that. Through featurize we could expose them to the agent but we refrain from that here since we want to simulate a scenario where the the source the agent controls is far away (e.g. 1km) from the load its supplying.  In cases like this it's common that the agent has no knowlegde about states of the load since no communication and measurements exchange between source and load is assumed.","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"In onther examples the electrical power grid consits of multiple sources and loads. The other sources are controlled by other agents or classic controllers. In that case, typically every controller / agent has knowlegde of the states of the source it controls but not about the states another agent/controller controls. (For more information see MultiController and inner_featurize of the env.)","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"featurize_ddpg = function(state, env, name)\n    if name == \"my_ddpg\"\n        norm_ref = env.nc.parameters[\"source\"][1][\"i_limit\"]\n        state = vcat(state, reference(env.t)/norm_ref)\n    end\nend","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"Before defining the environment, the reward() function has to be defined. It provides a feedback to the agent on how good the chosen action was. First, the state to be controlled is taken from the current environment state values. Since the states are normalized by the limits the electrical components can handle, a value greater than 1 means that the state limit is exceeded typically leading to a system crash. Therefore, first it is checked if the measured state is greater than 1. In that case a punishment is returned which, here, is chosen to be r = -1.","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"In case the controlled state is within the valid state space, the reward is caculated based on the error between the wanted reference value and the measured state value.  If these values are the same, meaning the agent perfectly fullfills the control task, a reward of r = 1 is returned to the agent. ( -> r in [-1, 1]). If the measured value differs from the reference, the error - based on the root-mean square error (RMSE) in this example - is substracted from the maximal reward: r = 1 - RMSE:","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"r = 1 - sqrtfraci_mathrmLref - i_mathrmL12","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"To keep the reward in the wanted range, the current difference is devided by 2. (E.g., in worst case, if a reference value equal to the corresponding current limit is chosen i_mathrmLref = i_mathrmlim and the measured current is the negative current limit i_mathrmL1 = -i_mathrmlim more the 1 would be substracted without this normaization).","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"function reward_function(env, name = nothing)\n    if name == \"my_ddpg\"\n        index_1 = findfirst(x -> x == \"source1_i_L1\", env.state_ids)\n        state_to_control = env.state[index_1]\n\n        if any(abs.(state_to_control).>1)\n            return -1\n        else\n\n            refs = reference(env.t)\n            norm_ref = env.nc.parameters[\"source\"][1][\"i_limit\"]          \n            r = 1-((abs.(refs/norm_ref - state_to_control)/2).^0.5)\n            return r \n        end\n    end\nend","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"Then, the defined parameters, featurize and reward functions are used to create an environment consisting of the electircal power grid. To keep the first learning example simple the action given to the env is internally not delayed. ","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"env = ElectricGridEnv(\n    CM = CM, \n    parameters = parameters, \n    t_end = 0.1, \n    featurize = featurize_ddpg, \n    reward_function = reward_function, \n    action_delay = 0)","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"In this example a Deep Deterministic Policy Gradient agent (https://arxiv.org/abs/1509.02971, https://spinningup.openai.com/en/latest/algorithms/ddpg.html) is chosen which can learn a control task on continous state and action spaces. It is configured using the CreateAgentDdpg() function which uses the information about the state and action ids, based on the parameter dict, stored in the agent_dict in the env:","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"env.agent_dict[chosen_key] (chosen key, here, my_ddpg):","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"\"source_number\": ID/number of the source the agent with this key controls\n\"mode\": Name of the agent\n\"action_ids\": List of strings with the action ids the agent controls/belong to the \"source_number\"`\n\"state_ids\": List of strings with the state ids the agent controls/belong to the \"source_number\"`","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"This information is used in the SetupAgents() method to configure the control-side of the experiment.","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"The agent is configured to receive as many inputs as environment returns for it's state (after featurize) and return as many outputs as actions requested from the env corresponding to the ids.","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"agent = CreateAgentDdpg(na = length(env.agent_dict[\"my_ddpg\"][\"action_ids\"]),\n                          ns = length(state(env, \"my_ddpg\")),\n                          use_gpu = false)","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"The SetupAgents() function takes the control types defined in the parameter dict and hands the correct indices to the corrensponding controllers / agents. The function returns controllers which is an instance of the MultiController which contains the different agents and classic controllers and maps their actions to the corresponding sources. ","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"Since in this example only one RL agent will be used it only contains the defined my_ddpg agent.  Therefore, the agent handed over to the SetupAgents() function is internally extended by a name to a named policy (https://juliareinforcementlearning.org/docs/rlcore/#ReinforcementLearningCore.NamedPolicy ). Using this name the MultiController (compare, https://juliareinforcementlearning.org/docs/rlzoo/#ReinforcementLearningZoo.MADDPGManager) enables to call the different agents/controllers via name during training and application.","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"To use the previously defined agent, a dict linking tha chosen_key: my_ddpg to the defined RL agent is handed over to the SetupAgents method: ","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"my_custom_agents = Dict(\"my_ddpg\" => agent)\n\ncontrollers = SetupAgents(env, my_custom_agents)","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"The controllers in this examples consits only of the one RL agent (my_ddpg) and can be trained usin the Learn() function to train 20 episodes:","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"Learn(controllers, env, num_episodes = 20)","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"After the training, the Simulate() function is used to run a test epiode without action noise and the state to be controlled (i_mathrmL1) is plotted:","category":"page"},{"location":"agents/","page":"Set up Agents","title":"Set up Agents","text":"\nstates_to_plot = [\"source1_i_L1\"]\nhook = DataHook(collect_state_ids = states_to_plot)\n\nSimulate(controllers, env, hook=hook)\n\nRenderHookResults(hook = hook,\n                  states_to_plot  = states_to_plot)","category":"page"},{"location":"classical/#**Classical-Controllers-Introduction**","page":"Set up Classical Controllers","title":"Classical Controllers Introduction","text":"","category":"section"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"There are a number of in-built \"classically\" control modes, which can be applied to the voltage sources. \nVoltage sources typically represent idealised effective models (or averaged models) of power electronic converters.","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"Classically controlled modes:","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":" Mode Description\n1 \"Swing\" Ideal voltage source without dynamics (i.e. an Infinite Bus)\n2 \"PQ\" Grid following controllable source/load (real and imaginary power)\n3 \"Droop\" Simple grid forming with power balancing through a droop mechanism\n4 \"Synchronverter\" or \"VSG\" Grid forming control mimicking a generator, i.e. Virtual Synchronous Generator","category":"page"},{"location":"classical/#Swing-Mode-Infinite-Bus","page":"Set up Classical Controllers","title":"Swing Mode - Infinite Bus","text":"","category":"section"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"This example is intended to introduce you to the simplest control mode available, i.e. \"open-loop\" control. \nOne source, a purely oscillating voltage source, that is generating a 3-phase AC signal while connected to a static load through a cable.\nPlotting of classial controller electrical quantities.","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"(Image: )","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"using JEG","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"_______________________________________________________________________________","category":"page"},{"location":"classical/#Network-Configuration","page":"Set up Classical Controllers","title":"Network Configuration","text":"","category":"section"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"We specify the control mode of the source as \"Swing\", often referred to as an infinite bus. \nThis is open-loop control of the source, where the output voltage magnitude, relative angle, and frequency at the source terminals are fixed.","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"# total run time, seconds\nt_end = 0.1     \n\n# Connectivity Matrix\nCM = [ 0. 1.\n        -1. 0.]     \n\nparameters = Dict{Any, Any}(\n        \"source\" => Any[\n                        Dict{Any, Any}(\"pwr\"   => 100e3,    # Power Rating [VAr]\n                                        \"mode\" => \"Swing\",  # Controller mode\n                                        \"v_pu_set\" => 1.05, # Voltage set point [per unit]\n                                        \"v_δ_set\" => 20.0), # Angle set point [degrees]\n                        ],\n        \"load\"   => Any[\n                        Dict{Any, Any}(\"impedance\" => \"RL\", \n                                        \"R\" => 3.73, \n                                        \"L\" => 0.019),\n                        ],\n        \"cable\"   => Any[\n                        Dict{Any, Any}(\"R\" => 0.1, \n                                        \"L\" => 0.25e-3, \n                                        \"C\" => 0.1e-4),\n                        ],\n        \"grid\"   => Dict{Any, Any}(\"f_grid\" => 60.0,        # Nominal grid frequency [Hz]\n                                    \"ramp_end\" => 0.04,     # Ramp up time to voltage set point [s]\n                                    \"v_rms\" => 230)         # Nominal grid voltage line-to-neutral [V]\n    );","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"_______________________________________________________________________________","category":"page"},{"location":"classical/#Defining-the-environment","page":"Set up Classical Controllers","title":"Defining the environment","text":"","category":"section"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"env = ElectricGridEnv(CM = CM, parameters = parameters, t_end = t_end, verbosity = 2);","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mNormalization is done based on the defined parameter limits.\n\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mTime simulation run time: 0.1 [s] ~> 1001 steps","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"_______________________________________________________________________________","category":"page"},{"location":"classical/#Initialising-the-agents","page":"Set up Classical Controllers","title":"Initialising the agents","text":"","category":"section"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"All sources are controlled within the reinforcement learning framework, even if the control mode selected for the source does not entail any \"learning\" or \"training\" of the control structure. ","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"If not specified by the user, for all the classically controlled \"agents\", the function SetupAgents computes all the necessary coefficients for control.","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"agent = SetupAgents(env);","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39m1 'classically' controlled source has been initialised.\n\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39m1 source has been set up in Swing mode.\n\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mAll 'classically' controlled sources have been automatically set up with droop coeficients, and proportional and integral gains.","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"_______________________________________________________________________________","category":"page"},{"location":"classical/#Running-the-time-simulation","page":"Set up Classical Controllers","title":"Running the time simulation","text":"","category":"section"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"The system is evolved for the specified amount of time, controller actions are computed, and the results are stored in a \"hook\". \nMost relevant quantities are automatically collected, however by passing a DataHook to the \"simulate\" function, signals may be specified.","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"hook = Simulate(agent, env);","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"_______________________________________________________________________________","category":"page"},{"location":"classical/#Under-the-Hood","page":"Set up Classical Controllers","title":"Under the Hood","text":"","category":"section"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"The software solves the electrical network in the time domain using a set of Linear Time Invariant ODEs.\nThe source voltage (action) and current through the filter inductor (state) of phase 'a' is shown below.","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"RenderHookResults(hook = hook, \n                    states_to_plot  = [\"source1_i_L1_a\"], # Inductor current [A]\n                    actions_to_plot = [\"source1_u_a\"],    # Source voltage [V]\n                    )","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"_______________________________________________________________________________","category":"page"},{"location":"classical/#High-Level-Plotting","page":"Set up Classical Controllers","title":"High-Level Plotting","text":"","category":"section"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"When sources are classically controlled and the network is a 3 phase system, the user has the option of plotting a number of additional quantities. \nThe only quantities that can be plotted for Reinforcement Learning controllers are those specified through \"statestoplot\" and \"actions\"to_plot\".\nThe elements of the vectors in the function \"plothookresult\" refer to the name of the classically controlled source which may differ if there are RL sources in the network, e.g. powerpinv = [1], indicates that the real power of the first classically controlled source should be plotted.","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"RenderHookResults(hook = hook, \n                    states_to_plot  = [], \n                    actions_to_plot = [],  \n                    power_p_inv     = [1], # Real power [Watts]\n                    power_q_inv     = [1], # Imaginary power [VAi]\n                    v_mag_inv       = [1], # Scaled L₂ norm in αβγ coordinates [V]\n                    i_mag_inv       = [1], # Scaled L₂ norm in αβγ coordinates [A]\n                    angles          = [1], # Relative angle [degrees]\n                    freq            = [1], # Angular velocity [Hz]\n                    )","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"_______________________________________________________________________________","category":"page"},{"location":"classical/#Analysis","page":"Set up Classical Controllers","title":"Analysis","text":"","category":"section"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"The plot shows the instantaneous 3-phase real [W] and imaginary [VAi] power delivered by the source. \nThe frequency is a constant 60 [Hz].\nThe relative positive phase sequence angle at the terminals of the source are 20 [degrees].\nThe voltage at the source terminals ramps up to a magnitude of 1.05*230 [V].","category":"page"},{"location":"classical/","page":"Set up Classical Controllers","title":"Set up Classical Controllers","text":"","category":"page"},{"location":"#JuliaElectricGrid.jl","page":"Welcome","title":"JuliaElectricGrid.jl","text":"","category":"section"},{"location":"","page":"Welcome","title":"Welcome","text":"JuliaElectricGrid, or JEG for short, is a library for setting up realistic electric grid simulations with extensive support for control options. With JEG you can","category":"page"},{"location":"","page":"Welcome","title":"Welcome","text":"Create a simulation environment for a electric grid by defining its sources, loads and cable connections\nSet detailled parameters of your electric components - or let them be auto-generated\nChoose different control modes for each source in your system\nUse the agent architecture of ReinforcementLearning.jl to either train RL agents as controllers or write your own ones","category":"page"},{"location":"","page":"Welcome","title":"Welcome","text":"The getting started pages of this documentation will guide you through the principles of working with JEG by following different examples and explaining them step by step. The example scripts can also be found in the examples folder of the JEG repository.","category":"page"},{"location":"#Installation","page":"Welcome","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome","title":"Welcome","text":"For now you have to download or clone the github repository at https://github.com/upb-lea/JuliaElectricGrid.jl and set it up:","category":"page"},{"location":"","page":"Welcome","title":"Welcome","text":"start up julia\nactivate the project by pressing ]to access pkg mode and then activate path/to/JEG or activate . if you started julia in your JuliaElectricGrid directory\nrun instantiate","category":"page"},{"location":"","page":"Welcome","title":"Welcome","text":"Now you should be ready to run the examples and work with JEG.","category":"page"}]
}
